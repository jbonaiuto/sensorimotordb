{% extends "base.html" %}
{% load staticfiles %}
{% block extrahead %}
<title>SensoriMotorDB - View Classification Analysis Results: {{ object.name }}</title>
<script type="text/javascript" src="{% static 'sensorimotordb/js/jquery-1.10.1.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/d3.min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/underscore-min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_functions.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_plot.js' %}"></script>
<script>

var classifications=[];
var current_unit_ids=[];
var factors=[];

// Mapping from factor level IDs to conditions
var level_mappings=new Map();
// Mapping from level ID to time window factor level settings
var timewindow_settings=new Map();

// Mapping from condition ID to unit ID to trial spikes
var condition_unit_trial_spikes=new Map();
// Mapping from condition ID to unit ID to trial events
var condition_unit_trial_events=new Map();

// Mapping from condition ID to unit ID to realigned and baseline-corrected firing rates
var realigned_condition_unit_rates=new Map();
// Mapping from condition ID to unit ID to realigned trial events
var realigned_condition_unit_trial_events=new Map();

// Mapping from factor ID to level ID to ?
var realigned_factor_level_mean_rates=new Map();
// Mapping from factor ID to level ID to ?
var realigned_factor_level_trial_events=new Map();

var factor_event_types=new Map();
var realigned_times=[];
var results;
var factor_plots=new Map();
var total_num_units=0;

$(document).ready(function(){
    // Load analysis results
    $('<img src="{% static 'sensorimotordb/img/loading.gif' %}"/>');
    var data = {};
    var args = {
        type: "GET",
        url: "/sensorimotordb/api/v1/classification_analysis_results/{{ object.id }}/?format=json",
        data: data,
        success: loadedAnalysisResultsData,
        error: function(data) {
            //alert("Something went wrong!");
        } };
    $.ajax(args);
});

/**
 * Loaded analysis results
 * @param resp
 */
function loadedAnalysisResultsData(resp)
{
    results=resp;
    classifications=resp.unit_classifications;
    // Mapping from level IDs to epoch names
    results.epochs={};
    for(var anova_idx=0; anova_idx<resp.analysis.analysis_anovas.length; anova_idx++)
    {
        for(var factor_idx=0; factor_idx<resp.analysis.analysis_anovas[anova_idx].factors.length; factor_idx++)
        {
            var factor=resp.analysis.analysis_anovas[anova_idx].factors[factor_idx];
            factors.push(factor);
            if(factor.type=='time window')
            {
                for(var level_idx=0; level_idx<factor.levels.length; level_idx++)
                {
                    var level=factor.levels[level_idx];
                    results.epochs[level.id]=level.value;
                }
            }
        }
    }

    // Fill in analysis info
    $('.analysis_results_info').each(function(index, element){
        $(this).empty();
        var tmplMarkup = $('#analysis_results-template').html();
        var compiledTmpl = _.template(tmplMarkup, results);
        $(this).append(compiledTmpl);
    });

    // List of conditions to load
    var conditions_to_load=[];

    // Figure out conditions per level and conditions to load
    for(var mapping_idx=0; mapping_idx<resp.settings.level_mappings.length; mapping_idx++)
    {
        var mapping=resp.settings.level_mappings[mapping_idx];
        var level_id=parseInt(mapping.level.split('/')[5]);
        level_mappings.set(level_id,[]);
        for(var condition_idx=0; condition_idx<mapping.conditions.length; condition_idx++)
        {
            var condition_id=parseInt(mapping.conditions[condition_idx].split('/')[5]);
            level_mappings.get(level_id).push(condition_id);
            if(conditions_to_load.indexOf(condition_id)<0)
                conditions_to_load.push(condition_id);
        }
    }

    // Get time window factor level settings
    for(var idx=0; idx<resp.settings.time_window_factor_level_settings.length; idx++)
    {
        var settings=resp.settings.time_window_factor_level_settings[idx];
        var level_id=parseInt(settings.level.split('/')[5]);
        timewindow_settings.set(level_id,settings);
    }

    // Process each unit
    total_num_units=resp.unit_analysis_results.length;
    // List of current units
    current_unit_ids=[];
    for(var unit_idx=0; unit_idx<total_num_units; unit_idx++)
    {
        // Get classification label
        var unit_results=resp.unit_analysis_results[unit_idx];
        current_unit_ids.push(unit_results.unit.id);
        for(var class_idx=0; class_idx<resp.unit_classifications.length; class_idx++)
        {
            for(var class_unit_idx=0; class_unit_idx<resp.unit_classifications[class_idx].units.length; class_unit_idx++)
            {
                if(resp.unit_classifications[class_idx].units[class_unit_idx].id==unit_results.unit.id)
                {
                    unit_results.classification=resp.unit_classifications[class_idx].type.label;
                    break
                }
            }
        }

        // Fill in unit results info
        unit_results.results_text=unit_results.results_text.replace(/\n/g,'<br>');
        unit_results.results_text=unit_results.results_text.replace(/ /g,'&nbsp;');
        unit_results.pairwise_results_text=unit_results.pairwise_results_text.replace(/\n/g,'<br>');
        unit_results.pairwise_results_text=unit_results.pairwise_results_text.replace(/ /g,'&nbsp;');
        $('.unit_analysis_results_list').each(function(index, element){
            unit_results.level=3;
            unit_results.idx=unit_idx;
            var tmplMarkup = $('#unit_analysis_results-template').html();
            var compiledTmpl = _.template(tmplMarkup, unit_results);
            $(this).append(compiledTmpl);
        });
    }

    // Update firing rates and plot if bin or kernel width or baseline epoch changed
    d3.selectAll("#binwidth").on("change", function(){ dispatch.statechange()});
    d3.selectAll("#kernelwidth").on("change", function(){ dispatch.statechange()});
    d3.selectAll("#baseline").on("change", function(){ dispatch.statechange()});
    dispatch.on("statechange", update_plot);

    // Build data structure for doughnut chart
    var data=[
        "All neurons",
        [
            -1,
            [],
            100
        ],
        {}
    ];
    // Add nodes to structure
    var classifications_added=[];
    // Until all classifications have been added
    while(classifications_added.length<resp.unit_classifications.length)
    {
        // Iterate through classifications
        for(var idx=0; idx<resp.unit_classifications.length; idx++)
        {
            /// If not already added
            if(classifications_added.indexOf(idx)<0)
            {
                var classification=resp.unit_classifications[idx];
                // If successfully added (won't be if parent not already added), add to structure
                if(addClassificationToHierarchy(data, classification))
                    classifications_added.push(idx);
            }
        }
    }

    // Create hierarchical plot
    d3.select(self.frameElement).style("height", "800px");
    init_code_hierarchy_plot("analysis_results-"+resp.id+"-pie", data);

    // Set rate to loading
    $('#analysis_results-'+results.id+'-mean_rate').empty();
    $('#analysis_results-'+results.id+'-mean_rate').append('<img src="/static/sensorimotordb/img/loading.gif">');

    // If conditions have not been loaded yet
    if(conditions_to_load.length>0)
    {
        // Initialize condition data structures
        for(var condition_idx=0; condition_idx<conditions_to_load.length; condition_idx++)
        {
            var condition_id=conditions_to_load[condition_idx];
            // Initialize map of condition-unit recordings
            condition_unit_trial_spikes.set(condition_id, new Map());
            condition_unit_trial_events.set(condition_id, new Map());
            realigned_condition_unit_rates.set(condition_id, new Map());
            realigned_condition_unit_trial_events.set(condition_id, new Map());
        }

        // Load recording trials for conditions
        var data = {};
        var args = {
            type: "GET",
            url: "/sensorimotordb/api/v1/full_recording_trial/?condition__in="+conditions_to_load.join(',')+"&limit=0&format=json",
            data: data,
            success: loadedRecordingTrialData,
            error: function(data) {
                //alert("Something went wrong!");
            } };
        $.ajax(args);
    }
    // Update firing rates and plot if already loaded
    else
    {
        update_firing_rates();
        plotFactors();
    }
}

/**
 * Recursive function to add a classification to the data hierarchy
 * @param data
 * @param classification
 * @return {Boolean}
 */
function addClassificationToHierarchy(data, classification)
{
    // If there is no parent for this classification or this node is the parent
    if(classification.type.parent==null || data[1][0]==parseInt(classification.type.parent.split('/')[5]))
    {
        var percentage=classification.units.length/data[1][1].length*100.0;
        if(classification.type.parent==null)
        {
            percentage=classification.units.length/total_num_units*100.0;
            // Add units to this node
            for(var unit_idx=0; unit_idx<classification.units.length; unit_idx++)
                data[1][1].push(classification.units[unit_idx]);
        }
        // Set node data
        data[2][classification.type.label]=[
            classification.type.label,
            [
                classification.type.id,
                classification.units,
                Math.round(percentage * 100) / 100
            ],
            {}
        ];
        return true;
    }
    else
    {
        // Loop through this node's children
        for(var child_label in data[2])
        {
            var child=data[2][child_label];
            // Stop if successfully added to child
            if(addClassificationToHierarchy(child, classification))
                return true;
        }
    }
    return false;
}


/**
 * Initialize hierarchical pie chart
 * @param element_id
 * @param data
 */
function init_code_hierarchy_plot(element_id, data)
{
    var plot = document.getElementById(element_id);

    while (plot.hasChildNodes())
    {
        plot.removeChild(plot.firstChild);
    }

    /**
     * Doughnut chart data structure count function - how many neurons in classification
     */
    function count_function(d)
    {
        return d[1][1].length;
    }

    /**
     * Generate a label for this classification
     * @param d
     * @return {String}
     */
    function label_function(d)
    {
        return d[2]+"\n"+d[4][1].length+" neurons\n"+d[4][2]+'%';
    }

    /**
     * Generate a legend for this classification
     * @param d
     * @return {String}
     */
    function legend_function(d)
    {
        return "<h3>"+d[2]+"</h3>";
    }

    var color = d3.scale.category20c();

    /**
     * Generate a color for this classification
     * @param d
     * @return {*}
     */
    function color_function(d)
    {
        return color(d[2]);
    }

    var width = 450;
    var height = width;
    var x_margin = 40;
    var y_margin = 40;

    var max_depth=3;

    var data_slices = [];
    var max_level = 4;

    var svg = d3.select("#"+element_id).append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height * .52 + ")");

    function process_data(data,level,start_deg,stop_deg)
    {
        var name = data[0];
        var total = count_function(data);
        var children = data[2];
        var current_deg = start_deg;
        if (level > max_level)
        {
            return;
        }
        if (start_deg == stop_deg)
        {
            return;
        }
        data_slices.push([start_deg,stop_deg,name,level,data[1]]);
        for (var key in children)
        {
            child = children[key];
            var inc_deg = (stop_deg-start_deg)/total*count_function(child);
            var child_start_deg = current_deg;
            current_deg+=inc_deg;
            var child_stop_deg = current_deg;
            var span_deg = child_stop_deg-child_start_deg;
            process_data(child,level+1,child_start_deg,child_stop_deg);
        }
    }

    process_data(data,0,0,360./180.0*Math.PI);

    var ref = data_slices[0];
    var next_ref = ref;
    var last_refs = [];

    var thickness = width/2.0/(max_level+2)*1.1;

    var arc = d3.svg.arc()
            .startAngle(function(d) { if(d[3]==0){return d[0];}return d[0]+0.01; })
            .endAngle(function(d) { if(d[3]==0){return d[1];}return d[1]-0.01; })
            .innerRadius(function(d) { return 1.1*d[3]*thickness; })
            .outerRadius(function(d) { return (1.1*d[3]+1)*thickness; });

    var slices = svg.selectAll(".form")
            .data(function(d) { return data_slices; })
            .enter()
            .append("g");
    slices.append("path")
            .attr("d", arc)
            .attr("id",function(d,i){return element_id+i;})
            .style("fill", function(d) { return color_function(d);})
            .attr("class","form");
    slices.on("click",animate);

    slices.append("svg:title")
            .text(label_function);


    function get_start_angle(d,ref)
    {
        if (ref)
        {
            var ref_span = ref[1]-ref[0];
            return (d[0]-ref[0])/ref_span*Math.PI*2.0
        }
        else
        {
            return d[0];
        }
    }

    function get_stop_angle(d,ref)
    {
        if (ref)
        {
            var ref_span = ref[1]-ref[0];
            return (d[1]-ref[0])/ref_span*Math.PI*2.0
        }
        else
        {
            return d[0];
        }
    }

    function get_level(d,ref)
    {
        if (ref)
        {
            return d[3]-ref[3];
        }
        else
        {
            return d[3];
        }
    }

    function rebaseTween(new_ref)
    {
        return function(d)
        {
            var level = d3.interpolate(get_level(d,ref),get_level(d,new_ref));
            var start_deg = d3.interpolate(get_start_angle(d,ref),get_start_angle(d,new_ref));
            var stop_deg = d3.interpolate(get_stop_angle(d,ref),get_stop_angle(d,new_ref));
            var opacity = d3.interpolate(100,0);
            return function(t)
            {
                return arc([start_deg(t),stop_deg(t),d[2],level(t)]);
            }
        }
    }

    var animating = false;

    function animate(d) {
        if (animating)
        {
            return;
        }
        var legend = d3.select("#"+element_id+"_legend")

        animating = true;
        var revert = false;
        var new_ref;
        if (d == ref && last_refs.length > 0)
        {
            revert = true;
            last_ref = last_refs.pop();
        }
        if (revert)
        {
            d = last_ref;
            legend.html(legend_function(d));
            loadUnitRates(d[4][1]);
            new_ref = ref;
            svg.selectAll(".form")
                    .filter(
                    function (b)
                    {
                        if (b[0].toFixed(5) >= last_ref[0].toFixed(5) && b[1].toFixed(5) <= last_ref[1].toFixed(5)  && b[3] >= last_ref[3])
                        {
                            return true;
                        }
                        return false;
                    }
            )
                    .transition().duration(1000).style("opacity","1").attr("pointer-events","all");
        }
        else
        {
            legend.html(legend_function(d));
            loadUnitRates(d[4][1]);
            new_ref = d;
            svg.selectAll(".form")
                    .filter(
                    function (b)
                    {
                        if (b[0].toFixed(5) < d[0].toFixed(5) || b[1].toFixed(5) > d[1].toFixed(5) || b[3] < d[3])
                        {
                            return true;
                        }
                        return false;
                    }
            )
                    .transition().duration(1000).style("opacity","0").attr("pointer-events","none");
        }
        svg.selectAll(".form")
                .filter(
                function (b)
                {
                    if (b[0].toFixed(5) >= new_ref[0].toFixed(5) && b[1].toFixed(5) <= new_ref[1].toFixed(5) && b[3] >= new_ref[3])
                    {
                        return true;
                    }
                    return false;
                }
        )
                .transition().duration(1000).attrTween("d",rebaseTween(d));
        setTimeout(function(){
            animating = false;
            if (! revert)
            {
                last_refs.push(ref);
                ref = d;
            }
            else
            {
                ref = d;
            }
        },1000);
    };

}

function loadUnitRates(units)
{
    // Update list of current units
    current_unit_ids=[];
    for(var unit_idx=0; unit_idx<units.length; unit_idx++)
    {
        var unit_id=units[unit_idx].id;
        current_unit_ids.push(unit_id);
    }

    // Show and hide right unit statistics
    for(var unit_results_idx=0; unit_results_idx<results.unit_analysis_results.length; unit_results_idx++)
    {
        var id=results.unit_analysis_results[unit_results_idx].id;
        var found=false;
        for(var unit_idx=0; unit_idx<units.length; unit_idx++)
        {
            var unit_id=units[unit_idx].id;
            if(units[unit_idx].id==results.unit_analysis_results[unit_results_idx].unit.id)
            {
                $('#unit_analysis_results-'+id).show();
                found=true;
                break
            }
        }
        if(!found)
            $('#unit_analysis_results-'+id).hide();
    }

    // Set rate to loading
    $('#analysis_results-'+results.id+'-mean_rate').empty();
    $('#analysis_results-'+results.id+'-mean_rate').append('<img src="/static/sensorimotordb/img/loading.gif">');


    update_firing_rates();
    plotFactors();
}

/**
 * Loaded recording trials for all conditions
 * @param resp
 */
function loadedRecordingTrialData(resp)
{
    // For each recording trial
    for(var j=0; j<resp.objects.length; j++)
    {
        var recording_trial=resp.objects[j];
        var trial_number=recording_trial.trial_number;
        var start_time=parseFloat(recording_trial.start_time);

        // Get condition ID
        var condition_id=parseInt(recording_trial.condition.split('/')[5]);

        // Iterate through unit recordings
        for(var k=0; k<recording_trial.unit_recordings.length; k++)
        {
            var unit_recording=recording_trial.unit_recordings[k];
            var unit=unit_recording.unit;

            // If this is the first instance of this unit in this condition
            if(!condition_unit_trial_spikes.get(condition_id).has(unit.id))
            {
                condition_unit_trial_events.get(condition_id).set(unit.id, []);
                condition_unit_trial_spikes.get(condition_id).set(unit.id, []);
            }

            // Add trial start event
            var start_event={
                t: start_time,
                trial: trial_number,
                name: 'start',
                description: 'trial start'
            };
            condition_unit_trial_events.get(condition_id).get(unit.id).push(start_event);
            
            // Add each event in trial
            for(var l=0; l<recording_trial.events.length; l++)
            {
                var evt=recording_trial.events[l];
                var current_event={
                    t: parseFloat(evt.time),
                    trial: trial_number,
                    name: evt.name,
                    description: evt.description
                };
                condition_unit_trial_events.get(condition_id).get(unit.id).push(current_event);
            }

            // Add unit spikes
            if(unit_recording.spike_times.length>0)
            {
                var spike_times=unit_recording.spike_times.split(',');
                for(var l=0; l<spike_times.length; l++)
                {
                    var spk={
                        x: parseFloat(spike_times[l]),
                        y: trial_number
                    };
                    condition_unit_trial_spikes.get(condition_id).get(unit.id).push(spk);
                }
            }
        }
    }

    // If no more recordings to load - update rates and plot
    if(resp.meta.next==null)
    {
        update_firing_rates();

        plotFactors();
    }
    // Otherwise load next batch
    else
    {
        var data = {};
        var args = {
            type: "GET",
            url: resp.meta.next,
            data: data,
            success: loadedRecordingTrialData,
            error: function(data) {
                //alert("Something went wrong!");
            } };
        $.ajax(args);
    }
}

/**
 * Update firing rates
 */
function update_firing_rates()
{
    // Get rate calculation parameters
    var align_event = d3.select("#align_event").node().value;
    var bin_width = parseInt(d3.select("#binwidth").node().value);
    var kernel_width = parseInt(d3.select("#kernelwidth").node().value);
    var baseline_epoch = parseInt(d3.select("#baseline").node().value);
    var baseline_setting=timewindow_settings.get(baseline_epoch);

    /**
     * Realign spikes and events
     */
    // Realigned spikes for each condition - map of unit recordings
    var realigned_condition_unit_spikes=new Map();
    // Min/max trial times
    var min_times=[];
    var max_times=[];
    var min_baseline_times=[];
    var max_baseline_times=[];
    for(let condition_id of condition_unit_trial_spikes.keys())
    {
        // realigned spikes for each condition
        realigned_condition_unit_spikes.set(condition_id,new Map());

        // For each unit in this condition
        for(let unit_id of condition_unit_trial_spikes.get(condition_id).keys())
        {
            var unit_trial_spikes=condition_unit_trial_spikes.get(condition_id).get(unit_id);
            var unit_trial_events=condition_unit_trial_events.get(condition_id).get(unit_id);

            // Realign spikes to align event
            var realigned_unit_trial_spikes=realign_spikes(unit_trial_spikes, unit_trial_events, align_event);
            realigned_condition_unit_spikes.get(condition_id).set(unit_id,realigned_unit_trial_spikes);

            // Realign trial events to align event
            var realigned_unit_trial_events=realign_events(unit_trial_events, align_event);
            realigned_condition_unit_trial_events.get(condition_id).set(unit_id, realigned_unit_trial_events);

            // Add min/max event times to min/max times array
            min_times.push(d3.min(realigned_unit_trial_events, function(d) { return d.t; }));
            max_times.push(d3.max(realigned_unit_trial_events, function(d) { return d.t; }));

            // Look for baseline times
            if(typeof baseline_setting != 'undefined')
            {
                for(let evt of realigned_unit_trial_events)
                {
                    // Baseline-relative event
                    if(evt.name==baseline_setting.rel_evt)
                    {
                        // Add baseline start time
                        min_baseline_times.push(evt.t+baseline_setting.rel_start);
                        // If absolute baseline duration
                        if(baseline_setting.rel_end_evt=='')
                            max_baseline_times.push(evt.t+baseline_setting.rel_end);
                    }
                    // Baseline-relative end event
                    else if(baseline_setting.rel_end_evt!='' && evt.name==baseline_setting.rel_end_evt)
                    {
                        max_baseline_times.push(evt.t);
                    }
                }
            }
        }
    }

    // Compute realigned time bins - common set of bins from min to max time for spike density calculation
    var min_time=d3.mean(min_times)-100;
    var max_time=d3.mean(max_times)+100;
    var xScale = d3.scale.linear().domain([min_time, max_time]);
    var bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);
    realigned_times=d3.range(xScale.domain()[0], xScale.domain()[1], bin_width);

    // Compute realigned baseline time bins - common set of bins from min to max baseline time
    var min_baseline_time=d3.mean(min_baseline_times);
    var max_baseline_time=d3.mean(max_baseline_times);
    var xScale = d3.scale.linear().domain([min_baseline_time, max_baseline_time]);
    var baseline_bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);

    /**
     *  Compute spike density (baseline-corrected) for each unit
     */
    for(let condition_id of realigned_condition_unit_spikes.keys())
    {
        for(let unit_id of realigned_condition_unit_spikes.get(condition_id).keys())
        {
            // Get the start and end of the baseline in each trial
            var unit_evts = realigned_condition_unit_trial_events.get(condition_id).get(unit_id);
            var trial_baseline_start={};
            var trial_baseline_end={};
            if(typeof baseline_setting != 'undefined')
            {
                for (var event_idx = 0; event_idx < unit_evts.length; event_idx++) {
                    var evt = unit_evts[event_idx];
                    if(evt.name==baseline_setting.rel_evt)
                    {
                        trial_baseline_start[evt.trial]=evt.t+baseline_setting.rel_start;
                        if(baseline_setting.rel_end_evt=='')
                            trial_baseline_end[evt.trial]=evt.t+baseline_setting.rel_end;
                    }
                    else if(baseline_setting.rel_end_evt!='' && evt.name==baseline_setting.rel_end_evt)
                    {
                        trial_baseline_end.push[evt.trial]=evt.t+baseline_setting.rel_end;
                    }
                }
            }

            // Get the unit's spikes in each trial, within the start and end time, and baseline spikes
            var unit_spikes=realigned_condition_unit_spikes.get(condition_id).get(unit_id);
            var within_cutoff_spikes=[];
            var baseline_spikes=[];
            for(var idx=0; idx<unit_spikes.length; idx++)
            {
                var spk=unit_spikes[idx];
                if(spk.x>=min_time && spk.x<=max_time)
                {
                    within_cutoff_spikes.push({
                        x: spk.x,
                        y: spk.y
                    });
                }
                if(typeof baseline_setting != 'undefined' && spk.x>=trial_baseline_start[spk.y] && spk.x<=trial_baseline_end[spk.y])
                {
                    baseline_spikes.push({
                        x: spk.x,
                        y: spk.y
                    });
                }
            }

            // Compute the spike density
            var spike_density=get_standard_spike_density(within_cutoff_spikes, bins, bin_width);

            // Baseline-correction
            if(typeof baseline_setting != 'undefined')
            {
                // Compute the spike density in the baseline period
                var baseline_spike_density=get_standard_spike_density(baseline_spikes, baseline_bins, bin_width);
                // Compute average baseline frequency
                var mean_baseline_spike_density=d3.mean(baseline_spike_density, function(d){ return d.y; });
                // Subtract mean baseline from spike density
                for(var idx=0; idx<spike_density.length; idx++)
                    spike_density[idx]={x: spike_density[idx].x,
                        y: spike_density[idx].y-mean_baseline_spike_density};
            }
            var rate=smooth_spike_density(spike_density, bin_width, kernel_width);
            realigned_condition_unit_rates.get(condition_id).set(unit_id,rate);
        }
    }

    /**
     * For each factor - normalize each unit's firing rate across levels, average unit firing rates within each level,
     * get event times
     */
    for(let factor of factors)
    {
        // If this is a factor that groups conditions together (rather than a time/epoch factor)
        if(factor.type=='condition')
        {
            //TODO: ?
            // Set types of events for this factor
            factor_event_types.set(factor.id, get_factor_all_event_types(factor, get_factor_event_types(factor)));

            // Reset factor trial events and mean firing rates
            realigned_factor_level_trial_events.set(factor.id, new Map());
            realigned_factor_level_mean_rates.set(factor.id, new Map());

            // TODO :?
            //var unit_max_rates = get_factor_unit_max_rates(factor);

            // Mapping from unit ID to level ID to condition ID to firing rate
            var unit_level_condition_rates=new Map();

            // Go through each level in this factor
            for (let level of factor.levels)
            {
                // If there is a mapping from this level to a set of conditions
                if(level_mappings.has(level.id))
                {
                    var level_mapping = level_mappings.get(level.id);

                    // Initialize list of trial events for this level
                    realigned_factor_level_trial_events.get(factor.id).set(level.id, []);


                    // For each condition mapped to this level
                    for (let condition_id of level_mapping)
                    {
                        // For each unit
                        //for (let unit_id of realigned_condition_unit_trial_events.get(condition_id).keys())
                        for (let unit_id of current_unit_ids)
                        {
                            // Get this unit's events in this condition
                            var unit_evts = realigned_condition_unit_trial_events.get(condition_id).get(unit_id);

                            // For each unit event
                            for (let evt of unit_evts)
                            {
                                // If this factor includes this type of event (TODO:?)
                                if (factor_event_types.get(factor.id).indexOf(evt.name) > -1)
                                {
                                    // Add to list of factor/level events
                                    realigned_factor_level_trial_events.get(factor.id).get(level.id).push(evt);
                                }
                            }

                            // Initialize
                            if(!unit_level_condition_rates.has(unit_id))
                                unit_level_condition_rates.set(unit_id, new Map());
                            if(!unit_level_condition_rates.get(unit_id).has(level.id))
                                unit_level_condition_rates.get(unit_id).set(level.id, new Map());
                            unit_level_condition_rates.get(unit_id).get(level.id).set(condition_id, realigned_condition_unit_rates.get(condition_id).get(unit_id));
                        }
                    }
                }
            }

            // Mapping from unit ID to level ID to mean firing rate over conditions within the level
            var unit_level_mean_rates=new Map();
            var level_unit_norm_rates=new Map();
            for(let unit_id of unit_level_condition_rates.keys())
            {
                unit_level_mean_rates.set(unit_id, new Map());
                var unit_level_peak_rates=[];
                for(let level_id of unit_level_condition_rates.get(unit_id).keys())
                {
                    // List of firing rates for each condition
                    var level_condition_unit_rates=[];
                    for(let condition_id of unit_level_condition_rates.get(unit_id).get(level_id).keys())
                    {
                        level_condition_unit_rates.push(unit_level_condition_rates.get(unit_id).get(level_id).get(condition_id));
                    }
                    // Compute mean firing rate of this unit over conditions in this level
                    var unit_level_mean_rate=mean_firing_rate(level_condition_unit_rates, realigned_times);
                    unit_level_mean_rates.get(unit_id).set(level_id, unit_level_mean_rate);
                    unit_level_peak_rates.push(d3.max(unit_level_mean_rate, function(d){return d.y}));
                }

                var unit_max_rate=d3.max(unit_level_peak_rates);
                for(let level_id of unit_level_condition_rates.get(unit_id).keys())
                {
                    if(!level_unit_norm_rates.has(level_id))
                        level_unit_norm_rates.set(level_id, []);

                    var unit_level_mean_rate=unit_level_mean_rates.get(unit_id).get(level_id);
                    level_unit_norm_rates.get(level_id).push(normalize_unit_rate(unit_level_mean_rate, unit_max_rate));
                }
            }

            for(let level_id of level_unit_norm_rates.keys())
            {
                var level_mean_rate=mean_firing_rate(level_unit_norm_rates.get(level_id), realigned_times);
                realigned_factor_level_mean_rates.get(factor.id).set(level_id, level_mean_rate);
            }
        }
    }

    function get_factor_event_types(factor) {
        var evt_types = [];
        for (var level_idx = 0; level_idx < factor.levels.length; level_idx++) {
            var level = factor.levels[level_idx];
            if(level_mappings.has(level.id))
            {
                var level_mapping = level_mappings.get(level.id);
                for (var condition_idx = 0; condition_idx < level_mapping.length; condition_idx++) {
                    var condition_id = level_mapping[condition_idx];
                    for (var unit_idx = 0; unit_idx < current_unit_ids.length; unit_idx++) {
                        var unit_id = current_unit_ids[unit_idx];
                        if (realigned_condition_unit_trial_events.get(condition_id).has(unit_id)) {
                            var unit_evts = realigned_condition_unit_trial_events.get(condition_id).get(unit_id);
                            for (var event_idx = 0; event_idx < unit_evts.length; event_idx++) {
                                var evt = unit_evts[event_idx];
                                if (evt_types.indexOf(evt.name) < 0)
                                    evt_types.push(evt.name);
                            }
                        }
                    }
                }
            }
        }
        return evt_types;
    }

    function get_factor_all_event_types(factor, evt_types) {
        var all_evt_types = [];
        for (var evt_type_idx = 0; evt_type_idx < evt_types.length; evt_type_idx++) {
            var evt_type = evt_types[evt_type_idx];
            var all_have = true;
            for (var level_idx = 0; level_idx < factor.levels.length; level_idx++) {
                var level = factor.levels[level_idx];
                if(level_mappings.has(level.id))
                {
                    var level_mapping = level_mappings.get(level.id);
                    var has_evt = false;
                    for (var condition_idx = 0; condition_idx < level_mapping.length; condition_idx++) {
                        var condition_id = level_mapping[condition_idx];
                        for (var unit_idx = 0; unit_idx < current_unit_ids.length; unit_idx++) {
                            var unit_id = current_unit_ids[unit_idx];
                            if (realigned_condition_unit_trial_events.get(condition_id).has(unit_id)) {
                                var unit_evts = realigned_condition_unit_trial_events.get(condition_id).get(unit_id);
                                for (var event_idx = 0; event_idx < unit_evts.length; event_idx++) {
                                    var evt = unit_evts[event_idx];
                                    if (evt.name == evt_type) {
                                        has_evt = true;
                                        break
                                    }
                                }
                            }
                            if (has_evt)
                                break
                        }
                        if (has_evt)
                            break
                    }
                    if (!has_evt) {
                        all_have = false;
                        break
                    }
                }
            }
            if (all_have)
                all_evt_types.push(evt_type);
        }
        return all_evt_types;
    }

}

function plotFactors()
{
    var parent_id="analysis_results-"+results.id+"-mean_rate";
    $('#'+parent_id).empty();
    factor_plots=new Map();
    for(var factor_idx=0; factor_idx<factors.length; factor_idx++)
    {
        var factor=factors[factor_idx];
        if(factor.type=='condition')
        {
            var factor_parent_id='analysis_results-'+results.id+'-factor-'+factor.id+'-mean_rate';
            $('#'+parent_id).append('<div id="'+factor_parent_id+'" style="text-align:center"><h3>'+factor.name+'</h3></div>');
            var level_ids=[];
            var level_labels=[];

            // Create a plot for this factor
            for(var level_idx=0; level_idx<factor.levels.length; level_idx++)
            {
                var level=factor.levels[level_idx];
                level_labels.push(level.value);
                level_ids.push(level.id);
            }

            var rate_svg=drawMeanNormalizedFiringRates(factor_parent_id, realigned_factor_level_mean_rates.get(factor.id),
                    realigned_factor_level_trial_events.get(factor.id), factor_event_types.get(factor.id),
                    level_ids, level_labels, 0.5);
            factor_plots.set(factor.id, rate_svg);
        }
    }
}

function update_plot()
{
    update_firing_rates();
    for(var factor_idx=0; factor_idx<factors.length; factor_idx++)
    {
        var factor=factors[factor_idx];
        if(factor.type=='condition')
            factor_plots.get(factor.id).update(realigned_factor_level_mean_rates.get(factor.id), realigned_factor_level_trial_events.get(factor.id));

    }

}

function exportToBODB(analysis_id)
{
    var win = window.open('{{ bodb_server }}/bodb/sed/neurophysiology/sensorimotordb/import/?_popup=1&analysis_id={{ object.id }}&api_key={{ api_key }}&user={{ username }}', 'Export to BODB', 'height=800,width=1000,resizable=yes,scrollbars=yes');
    win.focus();
    return false;
}

</script>
{% endblock %}
{% block content %}
<div class="analysis_results_info"></div>
<h2>Unit Analysis Results</h2>
<div class="unit_analysis_results_list"></div>
{% include "sensorimotordb/analysis/classification_analysis/classification_unit_analysis_results_list_item_template.html" %}
{% include "sensorimotordb/analysis/classification_analysis/classification_analysis_results_template.html" %}
{% endblock %}
	
