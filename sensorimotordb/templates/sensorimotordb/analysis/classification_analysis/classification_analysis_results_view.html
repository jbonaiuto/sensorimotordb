{% extends "base.html" %}
{% load staticfiles %}
{% block extrahead %}
<title>SensoriMotorDB - View Classification Analysis Results: {{ object.name }}</title>
<script type="text/javascript" src="{% static 'sensorimotordb/js/jquery-1.10.1.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/d3.min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/underscore-min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/FileSaver.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_functions.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_plot.js' %}"></script>
<script>

// Analysis results JSON object
var results;

// Unit IDs for the currently selected classification
var current_unit_ids=[];

// List of all factors
var factors=[];

// Map from conditions to condition names
var conditions=new Map();

// Original spike and event data,grouped by unit, then condition
var orig_unit_condition_data={
    // Mapping from unit ID to condition ID to trial spikes
    'spikes': new Map(),
    // Mapping from unit ID to condition ID to trial events
    'events': new Map(),
    // Mapping from unit ID to condition ID to num trials
    'numTrials': new Map()
};

// Realigned spike, rate, and event data, grouped by unit then condition
var realigned_unit_condition_data={
    // Mapping from unit ID to condition ID to realigned trial spikes
    'spikes': new Map(),
    // Mapping from unit ID to condition ID to realigned and baseline-corrected firing rates
    'rates': new Map(),
    // Mapping from unit ID to condition ID to realigned trial events
    'events': new Map()
};

// Rate and event data grouped by factor, then level
var factor_level_data={
    // Mapping from factor ID to level ID to mean, normalized, baseline corrected, and realigned rates
    'mean_rates': new Map(),
    // Mapping from factor ID to level ID to events
    'events': new Map(),
    // Mapping from factor ID to list of event types
    'event_types': new Map(),
    // Mapping from level IDs to conditions
    'level_mappings': new Map(),
    // Mapping from level ID to time window factor level settings
    'timewindow_settings': new Map()
};

// Factor and unit plots
var plots={
    'factor': new Map(),
    'unit': new Map()
};

// List of all event types
var event_types=['start'];

/**
 * Load analysis results data
 */
$(document).ready(function(){
    // Load analysis results
    $('<img src="{% static 'sensorimotordb/img/loading.gif' %}"/>');
    var data = {};
    var args = {
        type: "GET",
        url: "/sensorimotordb/api/v1/classification_analysis_results/{{ object.id }}/?format=json",
        data: data,
        success: loadedAnalysisResultsData,
        error: function(data) {
            //alert("Something went wrong!");
        } };
    $.ajax(args);
});

/**
 * Loaded analysis results
 * @param resp
 */
function loadedAnalysisResultsData(resp)
{
    results=resp;
    // Mapping from level IDs to epoch names
    results.epochs={};
    for(let factor of results.analysis.analysis_factors)
    {
        factors.push(factor);
        if(factor.type=='time window')
        {
            for(let level of factor.levels)
            {
                results.epochs[level.id]=level.value;
            }
        }
    }

    // Fill in analysis info
    $('.analysis_results_info').each(function(index, element){
        $(this).empty();
        var tmplMarkup = $('#analysis_results-template').html();
        var compiledTmpl = _.template(tmplMarkup, results);
        $(this).append(compiledTmpl);
    });

    // Figure out conditions per level and conditions to load
    for(let mapping of results.settings.level_mappings)
    {
        var level_id=parseInt(mapping.level.split('/')[5]);
        factor_level_data.level_mappings.set(level_id,[]);
        for(let condition of mapping.conditions)
        {
            factor_level_data.level_mappings.get(level_id).push(condition.id);
            if(!conditions.has(condition.id))
            {
                conditions.set(condition.id, condition.name);
            }
        }
    }

    // Get time window factor level settings
    for(let time_window_settings of results.settings.time_window_factor_level_settings)
    {
        var level_id=parseInt(time_window_settings.level.split('/')[5]);
        factor_level_data.timewindow_settings.set(level_id,time_window_settings);
    }

    // List of current units
    current_unit_ids=[];
    for(var unit_idx=0; unit_idx<results.unit_analysis_results.length; unit_idx++)
    {
        var unit_results=results.unit_analysis_results[unit_idx];
        // Get classification label
        current_unit_ids.push(unit_results.unit.id);
        for(let classification of results.unit_classifications)
        {
            for(let unit_classification of classification.units)
            {
                if(unit_classification.id==unit_results.unit.id)
                {
                    unit_results.classification=unit_classification.type.label;
                    break
                }
            }
        }

        orig_unit_condition_data.spikes.set(unit_results.unit.id, new Map());
        orig_unit_condition_data.events.set(unit_results.unit.id, new Map());
        orig_unit_condition_data.numTrials.set(unit_results.unit.id, new Map());
        realigned_unit_condition_data.spikes.set(unit_results.unit.id, new Map());
        realigned_unit_condition_data.rates.set(unit_results.unit.id, new Map());
        realigned_unit_condition_data.events.set(unit_results.unit.id, new Map());

        // Fill in unit results info
        unit_results.results_text=unit_results.results_text.replace(/\n/g,'<br>');
        unit_results.results_text=unit_results.results_text.replace(/ /g,'&nbsp;');
        $('.unit_analysis_results_list').each(function(index, element){
            unit_results.level=3;
            unit_results.idx=unit_idx;
            var tmplMarkup = $('#unit_analysis_results-template').html();
            var compiledTmpl = _.template(tmplMarkup, unit_results);
            $(this).append(compiledTmpl);
        });
    }

    // Update firing rates and plot if bin or kernel width or baseline epoch changed
    d3.selectAll("#binwidth").on("change", function(){ dispatch.statechange()});
    d3.selectAll("#kernelwidth").on("change", function(){ dispatch.statechange()});
    d3.selectAll("#baseline").on("change", function(){ dispatch.statechange()});
    dispatch.on("statechange", update_plot);

    // Build data structure for doughnut chart
    var data=[
        "All neurons",
        [
            -1,
            [],
            100
        ],
        {}
    ];
    // Add nodes to structure
    var classifications_added=[];
    // Until all classifications have been added
    while(classifications_added.length<results.unit_classifications.length)
    {
        // Iterate through classifications
        for(var idx=0; idx<results.unit_classifications.length; idx++)
        {
            /// If not already added
            if(classifications_added.indexOf(idx)<0)
            {
                var classification=results.unit_classifications[idx];
                // If successfully added (won't be if parent not already added), add to structure
                if(addClassificationToHierarchy(data, classification))
                    classifications_added.push(idx);
            }
        }
    }

    // Create hierarchical plot
    d3.select(self.frameElement).style("height", "800px");
    init_code_hierarchy_plot("analysis_results-"+results.id+"-pie", data);

    // Set rate to loading
    $('#analysis_results-'+results.id+'-mean_rate').empty();
    $('#analysis_results-'+results.id+'-mean_rate').append('<img src="/static/sensorimotordb/img/loading.gif">');

    // If conditions have not been loaded yet
    if(conditions.size>0)
    {
        // Load recording trials for conditions
        var data = {};
        var args = {
            type: "GET",
            url: "/sensorimotordb/api/v1/full_recording_trial/?condition__in="+Array.from(conditions.keys()).join(',')+"&limit=0&format=json",
            data: data,
            success: loadedRecordingTrialData,
            error: function(data) {
                //alert("Something went wrong!");
            } };
        $.ajax(args);
    }
    // Update firing rates and plot if already loaded
    else
    {
        update_firing_rates();
        plotFactors();
    }
}

/**
 * Recursive function to add a classification to the data hierarchy
 * @param data
 * @param classification
 * @return {Boolean}
 */
function addClassificationToHierarchy(data, classification)
{
    // If there is no parent for this classification or this node is the parent
    if(classification.type.parent==null || data[1][0]==parseInt(classification.type.parent.split('/')[5]))
    {
        var percentage=classification.units.length/data[1][1].length*100.0;
        if(classification.type.parent==null)
        {
            percentage=classification.units.length/results.unit_analysis_results.length*100.0;
            // Add units to this node
            for(var unit_idx=0; unit_idx<classification.units.length; unit_idx++)
                data[1][1].push(classification.units[unit_idx]);
        }
        // Set node data
        data[2][classification.type.label]=[
            classification.type.label,
            [
                classification.type.id,
                classification.units,
                Math.round(percentage * 100) / 100
            ],
            {}
        ];
        return true;
    }
    else
    {
        // Loop through this node's children
        for(var child_label in data[2])
        {
            var child=data[2][child_label];
            // Stop if successfully added to child
            if(addClassificationToHierarchy(child, classification))
                return true;
        }
    }
    return false;
}


/**
 * Initialize hierarchical pie chart
 * @param element_id
 * @param data
 */
function init_code_hierarchy_plot(element_id, data)
{
    var plot = document.getElementById(element_id);

    while (plot.hasChildNodes())
    {
        plot.removeChild(plot.firstChild);
    }

    /**
     * Doughnut chart data structure count function - how many neurons in classification
     */
    function count_function(d)
    {
        return d[1][1].length;
    }

    /**
     * Generate a label for this classification
     * @param d
     * @return {String}
     */
    function label_function(d)
    {
        return d[2]+"\n"+d[4][1].length+" neurons\n"+d[4][2]+'%';
    }

    /**
     * Generate a legend for this classification
     * @param d
     * @return {String}
     */
    function legend_function(d)
    {
        return "<h3>"+d[2]+"</h3>";
    }

    var color = d3.scale.category20c();

    /**
     * Generate a color for this classification
     * @param d
     * @return {*}
     */
    function color_function(d)
    {
        return color(d[2]);
    }

    var width = 450;
    var height = width;
    var x_margin = 40;
    var y_margin = 40;

    var max_depth=3;

    var data_slices = [];
    var max_level = 4;

    var svg = d3.select("#"+element_id).append("svg")
            .attr("width", width)
            .attr("height", height);

    var origin_transform=svg
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height * .52 + ")");

    function process_data(data,level,start_deg,stop_deg)
    {
        var name = data[0];
        var total = count_function(data);
        var children = data[2];
        var current_deg = start_deg;
        if (level > max_level)
        {
            return;
        }
        if (start_deg == stop_deg)
        {
            return;
        }
        data_slices.push([start_deg,stop_deg,name,level,data[1]]);
        for (var key in children)
        {
            child = children[key];
            var inc_deg = (stop_deg-start_deg)/total*count_function(child);
            var child_start_deg = current_deg;
            current_deg+=inc_deg;
            var child_stop_deg = current_deg;
            var span_deg = child_stop_deg-child_start_deg;
            process_data(child,level+1,child_start_deg,child_stop_deg);
        }
    }

    process_data(data,0,0,360./180.0*Math.PI);

    var ref = data_slices[0];
    var next_ref = ref;
    var last_refs = [];

    var thickness = width/2.0/(max_level+2)*1.1;

    var arc = d3.svg.arc()
            .startAngle(function(d) { if(d[3]==0){return d[0];}return d[0]+0.01; })
            .endAngle(function(d) { if(d[3]==0){return d[1];}return d[1]-0.01; })
            .innerRadius(function(d) { return 1.1*d[3]*thickness; })
            .outerRadius(function(d) { return (1.1*d[3]+1)*thickness; });

    var slices = origin_transform.selectAll(".form")
            .data(function(d) { return data_slices; })
            .enter()
            .append("g");
    slices.append("path")
            .attr("d", arc)
            .attr("id",function(d,i){return element_id+i;})
            .style("fill", function(d) { return color_function(d);})
            .attr("class","form");
    slices.on("click",animate);

    slices.append("svg:title")
            .text(label_function);


    function get_start_angle(d,ref)
    {
        if (ref)
        {
            var ref_span = ref[1]-ref[0];
            return (d[0]-ref[0])/ref_span*Math.PI*2.0
        }
        else
        {
            return d[0];
        }
    }

    function get_stop_angle(d,ref)
    {
        if (ref)
        {
            var ref_span = ref[1]-ref[0];
            return (d[1]-ref[0])/ref_span*Math.PI*2.0
        }
        else
        {
            return d[0];
        }
    }

    function get_level(d,ref)
    {
        if (ref)
        {
            return d[3]-ref[3];
        }
        else
        {
            return d[3];
        }
    }

    function rebaseTween(new_ref)
    {
        return function(d)
        {
            var level = d3.interpolate(get_level(d,ref),get_level(d,new_ref));
            var start_deg = d3.interpolate(get_start_angle(d,ref),get_start_angle(d,new_ref));
            var stop_deg = d3.interpolate(get_stop_angle(d,ref),get_stop_angle(d,new_ref));
            var opacity = d3.interpolate(100,0);
            return function(t)
            {
                return arc([start_deg(t),stop_deg(t),d[2],level(t)]);
            }
        }
    }

    var animating = false;

    function animate(d) {
        if (animating)
        {
            return;
        }
        var legend = d3.select("#"+element_id+"_legend")

        animating = true;
        var revert = false;
        var new_ref;
        if (d == ref && last_refs.length > 0)
        {
            revert = true;
            last_ref = last_refs.pop();
        }
        if (revert)
        {
            d = last_ref;
            legend.html(legend_function(d));
            loadUnitRates(d[4][1]);
            new_ref = ref;
            origin_transform.selectAll(".form")
                    .filter(
                    function (b)
                    {
                        if (b[0].toFixed(5) >= last_ref[0].toFixed(5) && b[1].toFixed(5) <= last_ref[1].toFixed(5)  && b[3] >= last_ref[3])
                        {
                            return true;
                        }
                        return false;
                    }
            )
                    .transition().duration(1000).style("opacity","1").attr("pointer-events","all");
        }
        else
        {
            legend.html(legend_function(d));
            loadUnitRates(d[4][1]);
            new_ref = d;
            origin_transform.selectAll(".form")
                    .filter(
                    function (b)
                    {
                        if (b[0].toFixed(5) < d[0].toFixed(5) || b[1].toFixed(5) > d[1].toFixed(5) || b[3] < d[3])
                        {
                            return true;
                        }
                        return false;
                    }
            )
                    .transition().duration(1000).style("opacity","0").attr("pointer-events","none");
        }
        origin_transform.selectAll(".form")
                .filter(
                function (b)
                {
                    if (b[0].toFixed(5) >= new_ref[0].toFixed(5) && b[1].toFixed(5) <= new_ref[1].toFixed(5) && b[3] >= new_ref[3])
                    {
                        return true;
                    }
                    return false;
                }
        )
                .transition().duration(1000).attrTween("d",rebaseTween(d));
        setTimeout(function(){
            animating = false;
            if (! revert)
            {
                last_refs.push(ref);
                ref = d;
            }
            else
            {
                ref = d;
            }
        },1000);
    };

    d3.select("#"+element_id+"_generate")
        .on("click", writeDownloadLink);

    function writeDownloadLink(){
        try {
            var isFileSaverSupported = !!new Blob();
        } catch (e) {
            alert("blob not supported");
        }

        var html = svg
            .attr("title", "test2")
            .attr("version", 1.1)
            .attr("xmlns", "http://www.w3.org/2000/svg")
            .node().parentNode.innerHTML;

        var blob = new Blob([html], {type: "image/svg+xml"});
        saveAs(blob, element_id+".svg");
    };
}

function loadUnitRates(units)
{
    // Update list of current units
    current_unit_ids=[];
    for(let unit of units)
    {
        current_unit_ids.push(unit.id);
        // Set rate to loading
        $('#unit-'+unit.id+'-plots').empty();
    }

    // Show and hide right unit statistics
    for(let unit_results of results.unit_analysis_results)
    {
        var found=false;
        for(let unit of units)
        {
            if(unit.id==unit_results.unit.id)
            {
                $('#unit_analysis_results-'+unit_results.id).show();
                $('#unit-'+unit.id+'-plots').append('<img src="/static/sensorimotordb/img/loading.gif">');
                found=true;
                break
            }
        }
        if(!found)
            $('#unit_analysis_results-'+unit_results.id).hide();
    }

    // Set rate to loading
    $('#analysis_results-'+results.id+'-mean_rate').empty();
    $('#analysis_results-'+results.id+'-mean_rate').append('<img src="/static/sensorimotordb/img/loading.gif">');


    update_firing_rates();
    plotFactors();
}

/**
 * Loaded recording trials for all conditions
 * @param resp
 */
function loadedRecordingTrialData(resp)
{
    // For each recording trial
    for(let recording_trial of resp.objects)
    {
        var trial_number=recording_trial.trial_number;
        var start_time=parseFloat(recording_trial.start_time);

        // Get condition ID
        var condition_id=parseInt(recording_trial.condition.split('/')[5]);

        // Iterate through unit recordings
        for(let unit_recording of recording_trial.unit_recordings)
        {
            var unit=unit_recording.unit;

            // If this is the first instance of this unit in this condition
            if(!orig_unit_condition_data.spikes.get(unit.id).has(condition_id))
            {
                orig_unit_condition_data.spikes.get(unit.id).set(condition_id, []);
                orig_unit_condition_data.events.get(unit.id).set(condition_id, []);
                orig_unit_condition_data.numTrials.get(unit.id).set(condition_id, 0);
            }

            // Update num trials
            orig_unit_condition_data.numTrials.get(unit.id).set(condition_id,
                    orig_unit_condition_data.numTrials.get(unit.id).get(condition_id)+1);

            // Add trial start event
            var start_event={
                t: start_time,
                trial: trial_number,
                name: 'start',
                description: 'trial start'
            };
            orig_unit_condition_data.events.get(unit.id).get(condition_id).push(start_event);
            
            // Add each event in trial
            for(let evt of recording_trial.events)
            {
                var current_event={
                    t: parseFloat(evt.time),
                    trial: trial_number,
                    name: evt.name,
                    description: evt.description
                };
                if(event_types.indexOf(current_event.name)<0)
                    event_types.push(current_event.name);
                orig_unit_condition_data.events.get(unit.id).get(condition_id).push(current_event);
            }

            // Add unit spikes
            if(unit_recording.spike_times.length>0)
            {
                var spike_times=unit_recording.spike_times.split(',');
                for(var l=0; l<spike_times.length; l++)
                {
                    var spk={
                        x: parseFloat(spike_times[l]),
                        y: trial_number
                    };
                    orig_unit_condition_data.spikes.get(unit.id).get(condition_id).push(spk);
                }
            }
        }
    }

    // If no more recordings to load - update rates and plot
    if(resp.meta.next==null)
    {
        update_firing_rates();

        plotFactors();
    }
    // Otherwise load next batch
    else
    {
        var data = {};
        var args = {
            type: "GET",
            url: resp.meta.next,
            data: data,
            success: loadedRecordingTrialData,
            error: function(data) {
                //alert("Something went wrong!");
            } };
        $.ajax(args);
    }
}

/**
 * Update firing rates
 */
function update_firing_rates()
{
    // Get rate calculation parameters
    var align_event = d3.select("#align_event").node().value;
    var bin_width = parseInt(d3.select("#binwidth").node().value);
    var kernel_width = parseInt(d3.select("#kernelwidth").node().value);
    // ID of level for epoch to use as baseline
    var baseline_epoch = parseInt(d3.select("#baseline").node().value);
    // Get baseline settings for this level
    var baseline_setting=factor_level_data.timewindow_settings.get(baseline_epoch);

    /**
     * Realign spikes and events
     */
    // Min/max trial times
    var min_times=[];
    var max_times=[];
    var min_baseline_times=[];
    var max_baseline_times=[];
    for(let unit_id of current_unit_ids)
    {
        // realigned spikes for each condition
        realigned_unit_condition_data.spikes.set(unit_id, new Map());
        realigned_unit_condition_data.rates.set(unit_id, new Map());
        realigned_unit_condition_data.events.set(unit_id, new Map());

        // For each unit in this condition
        for(let condition_id of conditions.keys())
        {
            var unit_trial_spikes=orig_unit_condition_data.spikes.get(unit_id).get(condition_id);
            var unit_trial_events=orig_unit_condition_data.events.get(unit_id).get(condition_id);

            // Realign spikes to align event
            realigned_unit_condition_data.spikes.get(unit_id).set(condition_id,
                    realign_spikes(unit_trial_spikes, unit_trial_events, align_event));

            // Realign trial events to align event
            var realigned_unit_trial_events=realign_events(unit_trial_events, align_event);
            realigned_unit_condition_data.events.get(unit_id).set(condition_id, realigned_unit_trial_events);

            // Add min/max event times to min/max times array
            min_times.push(d3.min(realigned_unit_condition_data.events.get(unit_id).get(condition_id), function(d) { return d.t; }));
            min_times.push(d3.min(realigned_unit_condition_data.spikes.get(unit_id).get(condition_id), function(d) { return d.x; }));
            max_times.push(d3.max(realigned_unit_condition_data.events.get(unit_id).get(condition_id), function(d) { return d.t; }));
            max_times.push(d3.max(realigned_unit_condition_data.spikes.get(unit_id).get(condition_id), function(d) { return d.x; }));

            // Look for baseline times
            if(typeof baseline_setting != 'undefined')
            {
                for(let evt of realigned_unit_trial_events)
                {
                    // Baseline-relative event
                    if(evt.name==baseline_setting.rel_evt)
                    {
                        // Add baseline start time
                        min_baseline_times.push(evt.t+baseline_setting.rel_start);
                        // If absolute baseline duration
                        if(baseline_setting.rel_end_evt=='')
                            max_baseline_times.push(evt.t+baseline_setting.rel_end);
                    }
                    // Baseline-relative end event
                    else if(baseline_setting.rel_end_evt!='' && evt.name==baseline_setting.rel_end_evt)
                    {
                        max_baseline_times.push(evt.t);
                    }
                }
            }
        }
    }

    // Compute realigned time bins - common set of bins from min to max time for spike density calculation
    //var min_time=d3.mean(min_times)-100;
    var min_time=d3.min(min_times);//-100;
    //var max_time=d3.mean(max_times)+100;
    var max_time=d3.max(max_times);//+100;
    var xScale = d3.scale.linear().domain([min_time, max_time]);
    var bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);
    var realigned_times=d3.range(xScale.domain()[0], xScale.domain()[1], bin_width);

    // Compute realigned baseline time bins - common set of bins from min to max baseline time
    var min_baseline_time=d3.mean(min_baseline_times);
    var max_baseline_time=d3.mean(max_baseline_times);
    var xScale = d3.scale.linear().domain([min_baseline_time, max_baseline_time]);
    var baseline_bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);

    /**
     *  Compute spike density (baseline-corrected) for each unit
     */
    for(let unit_id of current_unit_ids)
    {
        for(let condition_id of conditions.keys())
        {
            // Get the start and end of the baseline in each trial
            var unit_evts = realigned_unit_condition_data.events.get(unit_id).get(condition_id);
            var trial_baseline_start={};
            var trial_baseline_end={};
            if(typeof baseline_setting != 'undefined')
            {
                for (let evt of unit_evts)
                {
                    if(evt.name==baseline_setting.rel_evt)
                    {
                        trial_baseline_start[evt.trial]=evt.t+baseline_setting.rel_start;
                        if(baseline_setting.rel_end_evt=='')
                            trial_baseline_end[evt.trial]=evt.t+baseline_setting.rel_end;
                    }
                    else if(baseline_setting.rel_end_evt!='' && evt.name==baseline_setting.rel_end_evt)
                    {
                        trial_baseline_end.push[evt.trial]=evt.t+baseline_setting.rel_end;
                    }
                }
            }

            // Get the unit's spikes in each trial, within the start and end time, and baseline spikes
            var unit_spikes=realigned_unit_condition_data.spikes.get(unit_id).get(condition_id);
            var within_cutoff_spikes=[];
            var baseline_spikes=[];
            for(let spk of unit_spikes)
            {
                if(spk.x>=min_time && spk.x<=max_time)
                {
                    within_cutoff_spikes.push({
                        x: spk.x,
                        y: spk.y
                    });
                }
                if(typeof baseline_setting != 'undefined' && spk.x>=trial_baseline_start[spk.y] && spk.x<=trial_baseline_end[spk.y])
                {
                    baseline_spikes.push({
                        x: spk.x,
                        y: spk.y
                    });
                }
            }

            // Compute the spike density
            var spike_density=get_standard_spike_density(within_cutoff_spikes, bins, bin_width,
                    orig_unit_condition_data.numTrials.get(unit_id).get(condition_id));

            // Baseline-correction
            if(typeof baseline_setting != 'undefined')
            {
                // Compute the spike density in the baseline period
                var baseline_spike_density=get_standard_spike_density(baseline_spikes, baseline_bins, bin_width,
                        orig_unit_condition_data.numTrials.get(unit_id).get(condition_id));
                // Compute average baseline frequency
                var mean_baseline_spike_density=d3.mean(baseline_spike_density, function(d){ return d.y; });
                // Subtract mean baseline from spike density
                for(var idx=0; idx<spike_density.length; idx++)
                    spike_density[idx]={x: spike_density[idx].x,
                        y: spike_density[idx].y-mean_baseline_spike_density};
            }
            var rate=smooth_spike_density(spike_density, bin_width, kernel_width);
            realigned_unit_condition_data.rates.get(unit_id).set(condition_id,rate);
        }
    }

    /**
     * For each factor - normalize each unit's firing rate across levels, average unit firing rates within each level,
     * get event times
     */
    for(let factor of factors)
    {
        // If this is a factor that groups conditions together (rather than a time/epoch factor)
        if(factor.type=='condition')
        {
            //TODO: ?
            // Set types of events for this factor
            factor_level_data.event_types.set(factor.id, get_factor_all_event_types(factor, get_factor_event_types(factor)));

            // Reset factor trial events and mean firing rates
            factor_level_data.events.set(factor.id, new Map());
            factor_level_data.mean_rates.set(factor.id, new Map());

            // Mapping from unit ID to level ID to condition ID to firing rate
            var unit_level_condition_rates=new Map();

            // Go through each level in this factor
            for (let level of factor.levels)
            {
                // If there is a mapping from this level to a set of conditions
                if(factor_level_data.level_mappings.has(level.id))
                {
                    var level_mapping = factor_level_data.level_mappings.get(level.id);

                    // Initialize list of trial events for this level
                    factor_level_data.events.get(factor.id).set(level.id, []);


                    // For each condition mapped to this level
                    for (let condition_id of level_mapping)
                    {
                        // For each unit
                        for (let unit_id of current_unit_ids)
                        {
                            // Get this unit's events in this condition
                            var unit_evts = realigned_unit_condition_data.events.get(unit_id).get(condition_id);

                            // For each unit event
                            for (let evt of unit_evts)
                            {
                                // If this factor includes this type of event (TODO:?)
                                if (factor_level_data.event_types.get(factor.id).indexOf(evt.name) > -1)
                                {
                                    // Add to list of factor/level events
                                    factor_level_data.events.get(factor.id).get(level.id).push(evt);
                                }
                            }

                            // Initialize
                            if(!unit_level_condition_rates.has(unit_id))
                                unit_level_condition_rates.set(unit_id, new Map());
                            if(!unit_level_condition_rates.get(unit_id).has(level.id))
                                unit_level_condition_rates.get(unit_id).set(level.id, new Map());
                            unit_level_condition_rates.get(unit_id).get(level.id).set(condition_id, realigned_unit_condition_data.rates.get(unit_id).get(condition_id));
                        }
                    }
                }
            }

            // Mapping from unit ID to level ID to mean firing rate over conditions within the level
            var unit_level_mean_rates=new Map();
            var level_unit_norm_rates=new Map();
            for(let unit_id of current_unit_ids)
            {
                unit_level_mean_rates.set(unit_id, new Map());
                var unit_level_peak_rates=[];
                for(let level_id of unit_level_condition_rates.get(unit_id).keys())
                {
                    // List of firing rates for each condition
                    var level_condition_unit_rates=[];
                    for(let condition_id of unit_level_condition_rates.get(unit_id).get(level_id).keys())
                    {
                        level_condition_unit_rates.push(unit_level_condition_rates.get(unit_id).get(level_id).get(condition_id));
                    }
                    // Compute mean firing rate of this unit over conditions in this level
                    var unit_level_mean_rate=mean_firing_rate(level_condition_unit_rates, realigned_times);
                    unit_level_mean_rates.get(unit_id).set(level_id, unit_level_mean_rate);
                    unit_level_peak_rates.push(d3.max(unit_level_mean_rate, function(d){return d.y}));
                }

                var unit_max_rate=d3.max(unit_level_peak_rates);
                for(let level_id of unit_level_condition_rates.get(unit_id).keys())
                {
                    if(!level_unit_norm_rates.has(level_id))
                        level_unit_norm_rates.set(level_id, []);

                    var unit_level_mean_rate=unit_level_mean_rates.get(unit_id).get(level_id);
                    level_unit_norm_rates.get(level_id).push(normalize_unit_rate(unit_level_mean_rate, unit_max_rate));
                }
            }

            for(let level_id of level_unit_norm_rates.keys())
            {
                var level_mean_rate=mean_firing_rate(level_unit_norm_rates.get(level_id), realigned_times);
                factor_level_data.mean_rates.get(factor.id).set(level_id, level_mean_rate);
            }
        }
    }

    /**
     * Get list of all event types for given factor - all event types in all levels, all units
     * @param factor
     * @return {Array}
     */
    function get_factor_event_types(factor)
    {
        var evt_types = [];
        for (let level of factor.levels)
        {
            if(factor_level_data.level_mappings.has(level.id))
            {
                var level_mapping = factor_level_data.level_mappings.get(level.id);
                for (let condition_id of level_mapping)
                {
                    for (let unit_id of current_unit_ids)
                    {
                        if (realigned_unit_condition_data.events.get(unit_id).has(condition_id))
                        {
                            var unit_evts = realigned_unit_condition_data.events.get(unit_id).get(condition_id);
                            for (let evt of unit_evts)
                            {
                                if (evt_types.indexOf(evt.name) < 0)
                                    evt_types.push(evt.name);
                            }
                        }
                    }
                }
            }
        }
        return evt_types;
    }

    function get_factor_all_event_types(factor, evt_types)
    {
        var all_evt_types = [];
        for (let evt_type of evt_types)
        {
            var all_have = true;
            for (let level of factor.levels)
            {
                if(factor_level_data.level_mappings.has(level.id))
                {
                    var level_mapping = factor_level_data.level_mappings.get(level.id);
                    var has_evt = false;
                    for (let condition_id of level_mapping)
                    {
                        for (let unit_id of current_unit_ids)
                        {
                            if (realigned_unit_condition_data.events.get(unit_id).has(condition_id))
                            {
                                var unit_evts = realigned_unit_condition_data.events.get(unit_id).get(condition_id);
                                for (let evt of unit_evts)
                                {
                                    if (evt.name == evt_type) {
                                        has_evt = true;
                                        break
                                    }
                                }
                            }
                            if (has_evt)
                                break
                        }
                        if (has_evt)
                            break
                    }
                    if (!has_evt) {
                        all_have = false;
                        break
                    }
                }
            }
            if (all_have)
                all_evt_types.push(evt_type);
        }
        return all_evt_types;
    }

}

function plotFactors()
{
    var parent_id="analysis_results-"+results.id+"-mean_rate";
    $('#'+parent_id).empty();
    plots.factor=new Map();
    for(let factor of factors)
    {
        if(factor.type=='condition')
        {
            var factor_parent_id='analysis_results-'+results.id+'-factor-'+factor.id+'-mean_rate';
            var factor_legend_id='analysis_results-'+results.id+'-factor-'+factor.id+'_legend'
            $('#'+parent_id).append('<div id="'+factor_parent_id+'" style="text-align:center"><h3>'+factor.name+'</h3></div>');
            $('#'+parent_id).append('<div id="analysis_results-'+results.id+'-factor-'+factor.id+'_legend" class="legend"></div>');
            $('#'+parent_id).append('<button id="analysis_results-'+results.id+'-factor-'+factor.id+'-mean_rate_generate">Save as SVG</button>');
            var levels=new Map();

            // Create a plot for this factor
            for(let level of factor.levels)
            {
                levels.set(level.id,level.value);
            }

            var rate_svg=drawMeanNormalizedFiringRates(factor_parent_id, factor_legend_id, factor_level_data.mean_rates.get(factor.id),
                    factor_level_data.events.get(factor.id), factor_level_data.event_types.get(factor.id),
                    levels, 0.5);
            plots.factor.set(factor.id, rate_svg);
        }
    }
    plots.unit=new Map();
    for(let unit_id of current_unit_ids)
    {
        $('#unit-'+unit_id+'-plots').empty();
        $('#unit-'+unit_id+'-plots_legend').empty();
        var rate_svg=drawPopulationFiringRate('unit-'+unit_id+'-plots', 'unit-'+unit_id+'-plots_legend',
                realigned_unit_condition_data.rates.get(unit_id), realigned_unit_condition_data.events.get(unit_id),
                event_types, conditions, 0.5);
        plots.unit.set(unit_id, rate_svg);
    }
}

function update_plot()
{
    update_firing_rates();
    for(let factor of factors)
    {
        if(factor.type=='condition')
            plots.factor.get(factor.id).update(factor_level_data.mean_rates.get(factor.id), factor_level_data.events.get(factor.id));

    }
    for(let unit_id of current_unit_ids)
    {
        plots.unit.get(unit_id).update(realigned_unit_condition_data.rates.get(unit_id), realigned_unit_condition_data.events.get(unit_id));
    }
}

function exportToBODB(analysis_id)
{
    var win = window.open('{{ bodb_server }}/bodb/sed/neurophysiology/sensorimotordb/import/?_popup=1&analysis_id={{ object.id }}&api_key={{ api_key }}&user={{ username }}', 'Export to BODB', 'height=800,width=1000,resizable=yes,scrollbars=yes');
    win.focus();
    return false;
}

</script>
{% endblock %}
{% block content %}
<div class="analysis_results_info"></div>
<h2>Unit Analysis Results</h2>
<div class="unit_analysis_results_list"></div>
{% include "sensorimotordb/analysis/classification_analysis/classification_unit_analysis_results_list_item_template.html" %}
{% include "sensorimotordb/analysis/classification_analysis/classification_analysis_results_template.html" %}
{% endblock %}
	
