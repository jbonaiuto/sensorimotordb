{% extends "base.html" %}
{% load staticfiles %}
{% block extrahead %}
<title>SensoriMotorDB - View Analysis Results: {{ object.name }}</title>
<script type="text/javascript" src="{% static 'sensorimotordb/js/jquery-1.10.1.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/d3.min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/underscore-min.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_functions.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/neural_data_plot.js' %}"></script>
<script type="text/javascript" src="{% static 'sensorimotordb/js/d3pie.min.js' %}"></script>
<script>

    var classifications=[];
    var current_unit_ids=[];
    var factors=[];
    var conditions_to_load=[];
    var condition_unit_trials=new Map();
    var condition_unit_trial_events=new Map();
    var realigned_condition_unit_spikes=new Map();
    var realigned_condition_unit_trial_events=new Map();
    var results;
    var factor_plots=new Map();

    $(document).ready(function(){
        $('<img src="{% static 'sensorimotordb/img/loading.gif' %}"/>');
        var data = {};
        var args = {
            type: "GET",
            url: "/sensorimotordb/api/v1/visuomotor_classification_analysis_results/{{ object.id }}/?format=json",
            data: data,
            success: loadedAnalysisResultsData,
            error: function(data) {
                //alert("Something went wrong!");
            } };
        $.ajax(args);
    });

    /**
     * Loaded analysis results
     * @param resp
     */
    function loadedAnalysisResultsData(resp)
    {
        results=resp;
        classifications=resp.unit_classifications;
        factors=resp.analysis.factors;

        $('.analysis_results_info').each(function(index, element){
            $(this).empty();
            var tmplMarkup = $('#analysis_results-template').html();
            var compiledTmpl = _.template(tmplMarkup, results);
            $(this).append(compiledTmpl);
        });
        for(var unit_idx=0; unit_idx<resp.unit_analysis_results.length; unit_idx++)
        {
            var unit_results=resp.unit_analysis_results[unit_idx];
            for(var class_idx=0; class_idx<resp.unit_classifications.length; class_idx++)
            {
                for(var class_unit_idx=0; class_unit_idx<resp.unit_classifications[class_idx].units.length; class_unit_idx++)
                {
                    if(resp.unit_classifications[class_idx].units[class_unit_idx].id==unit_results.unit.id)
                    {
                        unit_results.classification=resp.unit_classifications[class_idx].label;
                        break
                    }
                }
            }
            unit_results.results_text=unit_results.results_text.replace(/\n/g,'<br>');
            unit_results.results_text=unit_results.results_text.replace(/ /g,'&nbsp;');
            unit_results.pairwise_results_text=unit_results.pairwise_results_text.replace(/\n/g,'<br>');
            unit_results.pairwise_results_text=unit_results.pairwise_results_text.replace(/ /g,'&nbsp;');
            $('.unit_analysis_results_list').each(function(index, element){
                unit_results.level=3;
                unit_results.idx=unit_idx;
                var tmplMarkup = $('#unit_analysis_results-template').html();
                var compiledTmpl = _.template(tmplMarkup, unit_results);
                $(this).append(compiledTmpl);
            });
        }
        d3.selectAll("#binwidth").on("change", function(){ dispatch.statechange()});
        d3.selectAll("#kernelwidth").on("change", function(){ dispatch.statechange()});
        dispatch.on("statechange", update);

        data=[];
        for(var idx=0; idx<resp.unit_classifications.length; idx++)
        {
             data.push({classification: resp.unit_classifications[idx], label: resp.unit_classifications[idx].label,
                value: resp.unit_classifications[idx].units.length, results_id: resp.id});
        }
        var pie_svg=drawPieChart(data, "analysis_results-"+resp.id+"-pie", onPieClick);
    }

    function onPieClick(info)
    {
        conditions_to_load=[];
        current_unit_ids=[];
        for(var unit_idx=0; unit_idx<info.data.classification.units.length; unit_idx++)
        {
            var unit_id=info.data.classification.units[unit_idx].id;
            current_unit_ids.push(unit_id);
        }

        for(var unit_results_idx=0; unit_results_idx<results.unit_analysis_results.length; unit_results_idx++)
        {
            var id=results.unit_analysis_results[unit_results_idx].id;
            var found=false;
            for(var unit_idx=0; unit_idx<info.data.classification.units.length; unit_idx++)
            {
                var unit_id=info.data.classification.units[unit_idx].id;
                if(info.data.classification.units[unit_idx].id==results.unit_analysis_results[unit_results_idx].unit.id)
                {
                    $('#unit_analysis_results-'+id).show();
                    found=true;
                    break
                }
            }
            if(!found)
                $('#unit_analysis_results-'+id).hide();
        }

        for(var factor_idx=0; factor_idx<factors.length; factor_idx++)
        {
            for(var level_idx=0; level_idx<factors[factor_idx].levels.length; level_idx++)
            {
                for(var condition_idx=0; condition_idx<factors[factor_idx].levels[level_idx].conditions.length; condition_idx++)
                {
                    var condition_id=factors[factor_idx].levels[level_idx].conditions[condition_idx].id;
                    if(conditions_to_load.indexOf(condition_id)<0 && !condition_unit_trials.has(condition_id))
                        conditions_to_load.push(condition_id);
                }
            }
        }
        $('#analysis_results-'+results.id+'-mean_rate').empty();
        $('#analysis_results-'+results.id+'-mean_rate').append('<img src="/static/sensorimotordb/img/loading.gif">');
        if(conditions_to_load.length>0)
        {
            for(var condition_idx=0; condition_idx<conditions_to_load.length; condition_idx++)
            {
                var condition_id=conditions_to_load[condition_idx];
                // Initialize map of condition-unit recordings
                condition_unit_trials.set(condition_id, new Map());
                condition_unit_trial_events.set(condition_id, new Map());
                realigned_condition_unit_spikes.set(condition_id, new Map());
                realigned_condition_unit_trial_events.set(condition_id, new Map());
            }

            // Load recording trials for condition
            var data = {};
            var args = {
                type: "GET",
                url: "/sensorimotordb/api/v1/full_recording_trial/?condition__in="+conditions_to_load.join(',')+"&limit=0&format=json",
                data: data,
                success: loadedRecordingTrialData,
                error: function(data) {
                    //alert("Something went wrong!");
                } };
            $.ajax(args);
        }
        else
            plotFactors();
    }

    /**
     * Loaded recording trials for a condition
     * @param resp
     */
    function loadedRecordingTrialData(resp)
    {
        // For each recording trial
        for(var j=0; j<resp.objects.length; j++)
        {
            var recording_trial=resp.objects[j];
            var trial_number=recording_trial.trial_number;
            var start_time=parseFloat(recording_trial.start_time);

            // Get condition ID
            var condition_id=parseInt(recording_trial.condition.split('/')[5]);

            // Iterate through unit recordings
            for(var k=0; k<recording_trial.unit_recordings.length; k++)
            {
                var unit_recording=recording_trial.unit_recordings[k];
                var unit=unit_recording.unit;

                // If this is the first instance of this unit in this condition
                if(~condition_unit_trials.get(condition_id).has(unit.id))
                {
                    condition_unit_trial_events.get(condition_id).set(unit.id, []);
                    condition_unit_trials.get(condition_id).set(unit.id, []);
                }

                var start_event={
                    t: start_time,
                    trial: trial_number,
                    name: 'start',
                    description: 'trial start'
                };
                condition_unit_trial_events.get(condition_id).get(unit.id).push(start_event);
                for(var l=0; l<recording_trial.events.length; l++)
                {
                    var evt=recording_trial.events[l];
                    var current_event={
                        t: parseFloat(evt.time),
                        trial: trial_number,
                        name: evt.name,
                        description: evt.description
                    };
                    condition_unit_trial_events.get(condition_id).get(unit.id).push(current_event);
                }

                var spike_times=unit_recording.spike_times.split(',');
                for(var l=0; l<spike_times.length; l++)
                {
                    var spk={
                        x: parseFloat(spike_times[l]),
                        y: trial_number
                    };
                    condition_unit_trials.get(condition_id).get(unit.id).push(spk);
                }
            }
        }

        var align_event = d3.select("#align_event").node().value;
        for(let condition_id of condition_unit_trials.keys())
        {
            for(let unit_id of condition_unit_trials.get(condition_id).keys())
            {
                if(condition_unit_trials.get(condition_id).has(unit_id))
                {
                    realigned_condition_unit_spikes.get(condition_id).set(unit_id,
                            realign_spikes(condition_unit_trials.get(condition_id).get(unit_id),
                                    condition_unit_trial_events.get(condition_id).get(unit_id), align_event));
                    realigned_condition_unit_trial_events.get(condition_id).set(unit_id,
                            realign_events(condition_unit_trial_events.get(condition_id).get(unit_id), align_event));
                }
            }
        }

        plotFactors();
    }

    function plotFactors()
    {
        var bin_width = parseInt(d3.select("#binwidth").node().value);
        var kernel_width = parseInt(d3.select("#kernelwidth").node().value);
        var parent_id="analysis_results-"+results.id+"-mean_rate";
        $('#'+parent_id).empty();
        factor_plots=new Map();
        for(var factor_idx=0; factor_idx<factors.length; factor_idx++)
        {
            var factor=factors[factor_idx];
            var factor_parent_id='analysis_results-'+results.id+'-factor-'+factor.id+'-mean_rate';
            $('#'+parent_id).append('<div id="'+factor_parent_id+'" style="text-align:center"></div>');
            var level_realigned_events=new Map();
            var event_types=[];
            var level_ids=[];
            var level_labels=[];

            var min_time=1000;
            var max_time=-1000;
            for(var level_idx=0; level_idx<factor.levels.length; level_idx++)
            {
                var level=factor.levels[level_idx];
                level_labels.push(level.value);
                level_ids.push(level.id);
                level_realigned_events.set(level.id,[]);

                for(var condition_idx=0; condition_idx<level.conditions.length; condition_idx++)
                {
                    var condition=level.conditions[condition_idx];
                    for(var unit_idx=0; unit_idx<current_unit_ids.length; unit_idx++)
                    {
                        var unit_id=current_unit_ids[unit_idx];
                        if(realigned_condition_unit_spikes.get(condition.id).has(unit_id))
                        {
                            var unit_spks=realigned_condition_unit_spikes.get(condition.id).get(unit_id);
                            var unit_min_time=d3.min(unit_spks, function(d) { return d.x; });
                            var unit_max_time=d3.max(unit_spks, function(d) { return d.x; });
                            if(unit_min_time<min_time)
                                min_time=unit_min_time;
                            if(unit_max_time>max_time)
                                max_time=unit_max_time;

                            var unit_evts=realigned_condition_unit_trial_events.get(condition.id).get(unit_id);
                            for(var event_idx=0; event_idx<unit_evts.length; event_idx++)
                            {
                                var evt=unit_evts[event_idx];
                                level_realigned_events.get(level.id).push(evt);
                                if(event_types.indexOf(evt.name)<0)
                                    event_types.push(evt.name);
                            }
                        }
                    }
                }
            }

            var xScale = d3.scale.linear()
                    .domain([min_time, max_time]);
            var bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);
            var times=d3.range(xScale.domain()[0], xScale.domain()[1], bin_width);

            var level_mean_rates=new Map();
            // Create a plot for this factor
            for(var level_idx=0; level_idx<factor.levels.length; level_idx++)
            {
                var level=factor.levels[level_idx];
                var condition_rates=[];

                for(var condition_idx=0; condition_idx<level.conditions.length; condition_idx++)
                {
                    var condition=level.conditions[condition_idx];
                    var unit_rates=[];
                    for(var unit_idx=0; unit_idx<current_unit_ids.length; unit_idx++)
                    {
                        var unit_id=current_unit_ids[unit_idx];
                        if(realigned_condition_unit_spikes.get(condition.id).has(unit_id))
                        {
                            var unit_spks=realigned_condition_unit_spikes.get(condition.id).get(unit_id);
                            // Compute unit firing rate
                            var rate=get_standard_firing_rate(unit_spks, bins, bin_width, kernel_width);

                            unit_rates.push(rate);
                        }
                    }
                    var condition_mean_rate=average_firing_rates(unit_rates, times);
                    condition_rates.push(condition_mean_rate);
                }
                var level_mean_rate=average_firing_rates(condition_rates, times);
                level_mean_rates.set(level.id, level_mean_rate);
            }

            var rate_svg=drawMeanFiringRates(factor_parent_id, level_mean_rates, level_realigned_events, event_types,
                    level_ids, level_labels, 0.5);
            factor_plots.set(factor.id, rate_svg);
        }
    }

    function average_firing_rates(rates, times)
    {
        var mean_rate=times.map(function(d,i){ return {x: d, y: d3.mean(rates.map(function(e){ return e[i].y })), stderr: d3.deviation(rates.map(function(e){ return e[i].y }))/Math.sqrt(rates.length)}});
        return mean_rate;
    }

    function drawMeanFiringRates(parent_id, mean_rates, group_trial_events, event_types, group_ids, group_names, scale_factor)
    {
        var margin = {top: 30, right: 20, bottom: 40, left: 50}
                , width = scale_factor*(960 - margin.left - margin.right)
                , height = scale_factor*(400 - margin.top - margin.bottom);

        var rate_svg = d3.select("#"+parent_id).append("svg:svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var min_time=10000;
        var max_time=-10000;
        var max_rate=0;
        for(var i=0; i<group_ids.length; i++)
        {
            var group_id=group_ids[i];
            var rate=mean_rates.get(group_id);
            var group_min_time=d3.min(rate, function(d){ return d.x; });
            var group_max_time=d3.max(rate, function(d){ return d.x; });
            if(group_min_time<min_time)
                min_time=group_min_time;
            if(group_max_time>max_time)
                max_time=group_max_time;
            var group_max_rate=d3.max(rate, function(d){ return d.y+ d.stderr });
            if(group_max_rate>max_rate)
                max_rate=group_max_rate;
        }

        var xScale = d3.scale.linear()
                .range([0, width])
                .domain([min_time, max_time]);

        var yScale = d3.scale.linear()
                .range([height, 0]);

        var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom");

        var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left");

        var line = d3.svg.line()
                .x(function(d) { return xScale(d.x); })
                .y(function(d) { return yScale(d.y); });

        yScale.domain([0, max_rate +.1*max_rate]);

        rate_svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

        rate_svg.append("svg:g")
                .attr("class", "y axis")
                .call(yAxis);

        var max_length=d3.max(group_names, function(d){return d.length});

        for(var group_idx=0; group_idx<group_ids.length; group_idx++)
        {
            var mean_rate=mean_rates.get(group_ids[group_idx]);

            // Define a convenience function to calculate the
            // path for a slice of the data.
            var slice = function(d,i) {
                var x = i ? mean_rate[i-1].x : d.x,
                        y = i ? mean_rate[i-1].y : d.y,
                        stderr = i ? mean_rate[i-1].stderr : d.stderr,
                        x0 = xScale(x),
                        x1 = xScale(d.x),
                        y0min = yScale(y - stderr),
                        y0max = yScale(y + stderr),
                        y1min = yScale(d.y - stderr),
                        y1max = yScale(d.y + stderr);
                return "M" + x0 + "," + y0min +
                        "L" + x0 + "," + y0max +
                        "L" + x1 + "," + y1max +
                        "L" + x1 + "," + y1min +
                        "L" + x0 + "," + y0min;
            }

            rate_svg.selectAll(".slice.mean_rates")
                    .data(mean_rate)
                   .enter().append("path")
                    .attr("class", "slice_dataset_"+group_ids[group_idx])
                    .attr("fill", p(group_idx))
                    .attr("fill-opacity", "0.4")
                    .attr("stroke", "none")
                    .attr("d", slice);

            rate_svg.append("path")
                    .attr("id", parent_id+"-group-"+group_ids[group_idx])
                    .datum(mean_rate)
                    .attr("class", "data-line")
                    .style("stroke", p(group_idx))
                    .attr("d", line);
            rate_svg.append("text")
                    .attr("class","legend-label")
                    .attr("x",width-max_length*7)
                    .attr("y",margin.top+group_idx*20)
                    .style("fill", p(group_idx))
                    .text(group_names[group_idx]);
        }

        rate_svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", width/2)
                .attr("y", height + margin.bottom)
                .text("Time (ms)");

        rate_svg.append("text")
                .attr("class", "axis-label")
                .attr("text-anchor", "middle")
                .attr("x", -height/2)
                .attr("y", -(margin.left-3))
                .attr("dy", ".75em")
                .attr("transform", "rotate(-90)")
                .text("Firing Rate (Hz)");

        // Events
        var event_notes=[];
        var event_lines=[];
        var event_areas=[];
        for(var i=0; i<event_types.length; i++)
        {
            var event_type=event_types[i];
            var times=[];
            for(var k=0; k<group_ids.length; k++)
            {
                var group_id=group_ids[k];
                var group_times=[];
                var realigned_trial_events=group_trial_events.get(group_id)
                for(var j=0; j<realigned_trial_events.length; j++)
                {
                    if(realigned_trial_events[j].name==event_type)
                        group_times.push(realigned_trial_events[j].t);
                }
                times.push(d3.mean(group_times));
            }
            var mean_time=d3.mean(times);
            var min_time=d3.min(times);
            var max_time=d3.max(times);
            event_lines.push(
                    rate_svg.append("line")
                            .attr("x1", xScale(mean_time))
                            .attr("y1", yScale(0))
                            .attr("x2", xScale(mean_time))
                            .attr("y2", yScale(max_rate +.1*max_rate))
                            .classed("annotation-line",true)
            );
            var area_x=xScale(min_time)+.5*(xScale(max_time)-xScale(min_time));
            event_areas.push(
                    rate_svg.append("line")
                            .attr("x1", area_x)
                            .attr("y1", yScale(0))
                            .attr("x2", area_x)
                            .attr("y2", yScale(max_rate +.1*max_rate))
                            .classed("annotation-line",true)
                            .style("stroke", p(i))
                            .style("stroke-width", (xScale(max_time)-xScale(min_time)+1)+"px")
            );
            event_notes.push(
                    rate_svg.selectAll(".g-note")
                            .data([event_type])
                            .enter().append("text")
                            .classed("annotation-text",true)
                            .style('fill', p(i))
                            .attr("x", xScale(mean_time))
                            .attr("y", yScale(max_rate +.1*max_rate))
                            .attr("dy", function(d, i) { return i * 1.3 + "em"; })
                            .text(function(d) { return d; })
                            .on("click", function(d) {
                                d3.select("#align_event").node().value= d;
                                dispatch.statechange();
                            })
            );
        }

        var focus = rate_svg.append("g")
                .attr("class", "focus")
                .style("display", "none");

        focus.append("circle")
                .attr("r", 4.5);

        focus.append("text")
                .attr("x", 9)
                .attr("dy", ".35em");

        rate_svg.append("rect")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)
                .on("mouseover", function() { focus.style("display", null); })
                .on("mouseout", function() { focus.style("display", "none"); })
                .on("mousemove", mousemove);

        function mousemove() {
            var x0 = xScale.invert(d3.mouse(this)[0]);
            var y0 = yScale.invert(d3.mouse(this)[1]);
            min_y_dist=10000;
            min_y_d=null;
            for(var j=0; j<group_ids.length; j++)
            {
                rate=mean_rates.get(group_ids[j]);
                var i = bisectTime(rate, x0, 1);
                d0 = rate[i - 1];
                d1 = rate[i];
                d = x0 - d0.x > d1.x - x0 ? d1 : d0;
                y_dist=Math.abs(d.y-y0);
                if(y_dist<min_y_dist)
                {
                    min_y_dist=y_dist;
                    min_y_d=d;
                }
            }
            focus.attr("transform", "translate(" + xScale(min_y_d.x) + "," + yScale(min_y_d.y) + ")");
            focus.select("text").text(min_y_d.y.toFixed(2)+'Hz');
        }

        rate_svg.update=function update(realigned_mean_rates, realigned_trial_events){
            binwidth = parseInt(d3.select("#binwidth").node().value);
            kernelwidth = parseInt(d3.select("#kernelwidth").node().value);
            var min_time=10000;
            var max_time=-10000;
            var max_rate=0;
            for(var i=0; i<group_ids.length; i++)
            {
                var group_id=group_ids[i];
                var rate=realigned_mean_rates.get(group_id);
                var group_min_time=d3.min(rate, function(d){ return d.x; });
                var group_max_time=d3.max(rate, function(d){ return d.x; });
                if(group_min_time<min_time)
                    min_time=group_min_time;
                if(group_max_time>max_time)
                    max_time=group_max_time;
                var group_max_rate=d3.max(rate, function(d){ return d.y+1 });
                if(group_max_rate>max_rate)
                    max_rate=group_max_rate;

            }

            yScale.domain([0, max_rate +.1*max_rate]);
            yAxis.scale(yScale);
            xScale.domain([min_time, max_time]);
            xAxis.scale(xScale);

            xBinwidth =  width / (rate.length-1)
            for(var i=0; i<event_types.length; i++)
            {
                var event_type=event_types[i];
                var times=[];
                for(var k=0; k<group_ids.length; k++)
                {
                    var group_id=group_ids[k];
                    var group_times=[];
                    var trial_events=realigned_trial_events.get(group_id);
                    for(var j=0; j<trial_events.length; j++)
                    {
                        if(trial_events[j].name==event_type)
                            group_times.push(trial_events[j].t);
                    }
                    times.push(d3.mean(group_times));
                }
                var mean_time=d3.mean(times);
                var min_time=d3.min(times);
                var max_time=d3.max(times);
                event_lines[i]
                        .attr("x1", xScale(mean_time))
                        .attr("x2",xScale(mean_time));
                var area_x=xScale(min_time)+.5*(xScale(max_time)-xScale(min_time));
                event_areas[i]
                        .attr("x1", area_x)
                        .attr("x2", area_x)
                        .style("stroke-width", (xScale(max_time)-xScale(min_time)+1)+"px");
                event_notes[i].attr("x", xScale(mean_time))
            }

            for(var i=0; i<group_ids.length; i++)
            {
                var group_id=group_ids[i];
                var mean_rate=realigned_mean_rates.get(group_id);
                rate_svg.selectAll('#'+parent_id+'-group-'+group_id).datum(mean_rate)
                        .transition().duration(1000)
                        .attr("class", "data-line")
                        .attr("d", line);
                var slice = function(d,i) {
                    var x = i ? mean_rate[i-1].x : d.x,
                            y = i ? mean_rate[i-1].y : d.y,
                            stderr = i ? mean_rate[i-1].stderr : d.stderr,
                            x0 = xScale(x),
                            x1 = xScale(d.x),
                            y0min = yScale(y - stderr),
                            y0max = yScale(y + stderr),
                            y1min = yScale(d.y - stderr),
                            y1max = yScale(d.y + stderr);
                    return "M" + x0 + "," + y0min +
                            "L" + x0 + "," + y0max +
                            "L" + x1 + "," + y1max +
                            "L" + x1 + "," + y1min +
                            "L" + x0 + "," + y0min;
                }
                rate_svg.selectAll(".slice_dataset_"+group_id).data(mean_rate)
                        .transition().duration(1000)
                        .attr("d", slice);
            }
            rate_svg.selectAll(".text").data(hist).remove();
            rate_svg.select(".y.axis").call(yAxis);
            rate_svg.select(".x.axis").call(xAxis);

        }
        dispatch.on("realigned.rate.population."+parent_id, rate_svg.update);
        return rate_svg;
    }

    function update()
    {
        var align_event = d3.select("#align_event").node().value;
        var bin_width = parseInt(d3.select("#binwidth").node().value);
        var kernel_width = parseInt(d3.select("#kernelwidth").node().value);

        var min_time=1000;
        var max_time=-1000;
        for(let condition_id of condition_unit_trials.keys())
        {
            for(let unit_id of condition_unit_trials.get(condition_id).keys())
            {
                realigned_condition_unit_spikes.get(condition_id).set(unit_id,
                        realign_spikes(condition_unit_trials.get(condition_id).get(unit_id),
                                condition_unit_trial_events.get(condition_id).get(unit_id), align_event));
                realigned_condition_unit_trial_events.get(condition_id).set(unit_id,
                        realign_events(condition_unit_trial_events.get(condition_id).get(unit_id), align_event));
                if(current_unit_ids.indexOf(unit_id)>-1)
                {
                    var unit_min_time=d3.min(realigned_condition_unit_spikes.get(condition_id).get(unit_id), function(d) { return d.x; });
                    var unit_max_time=d3.max(realigned_condition_unit_spikes.get(condition_id).get(unit_id), function(d) { return d.x; });
                    if(unit_min_time<min_time)
                        min_time=unit_min_time;
                    if(unit_max_time>max_time)
                        max_time=unit_max_time;
                }
            }
        }

        var xScale = d3.scale.linear()
                .domain([min_time, max_time]);
        var bins=d3.range(xScale.domain()[0], xScale.domain()[1]+bin_width, bin_width);
        var times=d3.range(xScale.domain()[0], xScale.domain()[1], bin_width);

        for(var factor_idx=0; factor_idx<factors.length; factor_idx++)
        {
            var factor=factors[factor_idx];
            var level_mean_rates=new Map();
            var level_realigned_events=new Map();
            // Create a plot for this factor
            for(var level_idx=0; level_idx<factor.levels.length; level_idx++)
            {
                var level=factor.levels[level_idx];
                var condition_rates=[];
                level_realigned_events.set(level.id,[]);

                for(var condition_idx=0; condition_idx<level.conditions.length; condition_idx++)
                {
                    var condition=level.conditions[condition_idx];
                    var unit_rates=[];
                    for(var unit_idx=0; unit_idx<current_unit_ids.length; unit_idx++)
                    {
                        var unit_id=current_unit_ids[unit_idx];
                        if(realigned_condition_unit_spikes.get(condition.id).has(unit_id))
                        {
                            var unit_spks=realigned_condition_unit_spikes.get(condition.id).get(unit_id);
                            // Compute unit firing rate
                            var rate=get_standard_firing_rate(unit_spks, bins, bin_width, kernel_width);

                            unit_rates.push(rate);

                            var unit_evts=realigned_condition_unit_trial_events.get(condition.id).get(unit_id);
                            for(var event_idx=0; event_idx<unit_evts.length; event_idx++)
                            {
                                var evt=unit_evts[event_idx];
                                level_realigned_events.get(level.id).push(evt);
                            }
                        }
                    }
                    var condition_mean_rate=average_firing_rates(unit_rates, times);
                    condition_rates.push(condition_mean_rate);
                }
                var level_mean_rate=average_firing_rates(condition_rates, times);
                level_mean_rates.set(level.id, level_mean_rate);
            }
            factor_plots.get(factor.id).update(level_mean_rates, level_realigned_events);

        }

    }

</script>
{% endblock %}
{% block content %}
    <div class="analysis_results_info"></div>
    <h2>Unit Analysis Results</h2>
    <div class="unit_analysis_results_list"></div>
    {% include "sensorimotordb/analysis/visuomotor_classification_unit_analysis_results_list_item_template.html" %}
    {% include "sensorimotordb/analysis/visuomotor_classification_analysis_results_template.html" %}
{% endblock %}
